import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as s,c as a,e as t}from"./app-Ba--U_Af.js";const p={},e=t(`<h1 id="数据结构04-快速链表" tabindex="-1"><a class="header-anchor" href="#数据结构04-快速链表"><span>数据结构04-快速链表</span></a></h1><p><img src="https://cdn.dhbin.cn/202303232003998.jpeg" alt="img"></p><p>（开局一张图，下面全靠编）</p><p>在Redis 3.2之前的版本，Redis使用压缩链表（ziplist）和双端链表（adlist）来实现List。当元素个数比较少的情况下，使用压缩链表，当数据到一定的量，升级为双端链表。这是因为压缩链表可以节省内存空间，但压缩链表的数据是连续的，数据的插入压缩链表需要重新分配内存，这会影响到压缩链表的执行效率，所以升级到双端链表。快速链表是综合考虑时间效率和空间效率引入的新型数据结构。</p><h2 id="原理" tabindex="-1"><a class="header-anchor" href="#原理"><span>原理</span></a></h2><p>因为压缩链表的内存是连续的，在插入的时候需要重新分配内存，快速链表的解决方案就是把一整个链表插分成多个压缩链表，通过链表节点的方式串联起来。从而在新的数据插入的时候操作的内存变小了。整体提升时间效率，也能很好的使用压缩链表的空间压缩能力。</p><h2 id="数据结构" tabindex="-1"><a class="header-anchor" href="#数据结构"><span>数据结构</span></a></h2><h3 id="quicklist" tabindex="-1"><a class="header-anchor" href="#quicklist"><span>quicklist</span></a></h3><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/* quicklist is a 40 byte struct (on 64-bit systems) describing a quicklist.
 * &#39;count&#39; is the number of total entries.
 * &#39;len&#39; is the number of quicklist nodes.
 * &#39;compress&#39; is: 0 if compression disabled, otherwise it&#39;s the number
 *                of quicklistNodes to leave uncompressed at ends of quicklist.
 * &#39;fill&#39; is the user-requested (or default) fill factor.
 * &#39;bookmakrs are an optional feature that is used by realloc this struct,
 *      so that they don&#39;t consume memory when not used. */</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">quicklist</span> <span class="token punctuation">{</span>
    quicklistNode <span class="token operator">*</span>head<span class="token punctuation">;</span>
    quicklistNode <span class="token operator">*</span>tail<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> count<span class="token punctuation">;</span>        <span class="token comment">/* total count of all entries in all ziplists */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> len<span class="token punctuation">;</span>          <span class="token comment">/* number of quicklistNodes */</span>
    <span class="token keyword">int</span> fill <span class="token operator">:</span> QL_FILL_BITS<span class="token punctuation">;</span>              <span class="token comment">/* fill factor for individual nodes */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> compress <span class="token operator">:</span> QL_COMP_BITS<span class="token punctuation">;</span> <span class="token comment">/* depth of end nodes not to compress;0=off */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> bookmark_count<span class="token operator">:</span> QL_BM_BITS<span class="token punctuation">;</span>
    quicklistBookmark bookmarks<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> quicklist<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>head：头部节点</li><li>tail：尾部节点</li><li>count：链表的元素数量</li><li>len：快速链表中quicklistNode数量</li><li>fill：这个值决定了单个Node的内存空间，后面详细说</li><li>compress：首尾节点不压缩，表示允许压缩节点的数量</li></ul><h3 id="quicklistnode" tabindex="-1"><a class="header-anchor" href="#quicklistnode"><span>quicklistNode</span></a></h3><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/* quicklistNode is a 32 byte struct describing a ziplist for a quicklist.
 * We use bit fields keep the quicklistNode at 32 bytes.
 * count: 16 bits, max 65536 (max zl bytes is 65k, so max count actually &lt; 32k).
 * encoding: 2 bits, RAW=1, LZF=2.
 * container: 2 bits, NONE=1, ZIPLIST=2.
 * recompress: 1 bit, bool, true if node is temporary decompressed for usage.
 * attempted_compress: 1 bit, boolean, used for verifying during testing.
 * extra: 10 bits, free for future use; pads out the remainder of 32 bits */</span>
<span class="token comment">/*
 * 快速链表节点是一个32位大小的结构体，用来描述当前压缩链表的一些属性
 * count： 16位，最大值是65536
 * encoding：2位，标识是否压缩
 * container：2位，这个值在现在的版本只有一个值，2
 * recompress：1位，如果是1的话，表示这个压缩链表被压缩过了
 * attempted_compress：测试使用
 * extra：占位
 * */</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">quicklistNode</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">quicklistNode</span> <span class="token operator">*</span>prev<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">quicklistNode</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>zl<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> sz<span class="token punctuation">;</span>             <span class="token comment">/* ziplist size in bytes */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> count <span class="token operator">:</span> <span class="token number">16</span><span class="token punctuation">;</span>     <span class="token comment">/* count of items in ziplist */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> encoding <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">;</span>   <span class="token comment">/* RAW==1 or LZF==2 */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> container <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token comment">/* NONE==1 or ZIPLIST==2 */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> recompress <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">/* was this node previous compressed? */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> attempted_compress <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">/* node can&#39;t compress; too small */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> extra <span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">/* more bits to steal for future usage */</span>
<span class="token punctuation">}</span> quicklistNode<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="逻辑" tabindex="-1"><a class="header-anchor" href="#逻辑"><span>逻辑</span></a></h2><h3 id="如何判断quicklistnode能否继续插入数据" tabindex="-1"><a class="header-anchor" href="#如何判断quicklistnode能否继续插入数据"><span>如何判断quicklistNode能否继续插入数据</span></a></h3><p>受quicklist中的fill字段限制</p><p>如果fill是负数：fill的值关系到压缩链表的字节大小，关系如下</p><div class="language-plain line-numbers-mode" data-ext="plain" data-title="plain"><pre class="language-plain"><code>{-2  , -3  , -4   , -5   , -6  }
{4096, 8192, 16384, 32768, 65536}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>计算公式是 (-fill) - 1 = 数组的偏移量，节点的字节数小于对应的值则可以继续插入。</p><p>如果fill是正数：fill的值大于8192的话，不允许，如果节点的元素数量小于fill，允许，否则不允许。</p><h3 id="初始化" tabindex="-1"><a class="header-anchor" href="#初始化"><span>初始化</span></a></h3><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code>quicklist <span class="token operator">*</span><span class="token function">quicklistCreate</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">quicklist</span> <span class="token operator">*</span>quicklist<span class="token punctuation">;</span>

    quicklist <span class="token operator">=</span> <span class="token function">zmalloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>quicklist<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    quicklist<span class="token operator">-&gt;</span>head <span class="token operator">=</span> quicklist<span class="token operator">-&gt;</span>tail <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    quicklist<span class="token operator">-&gt;</span>len <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    quicklist<span class="token operator">-&gt;</span>count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment">/* 是否压缩节点 */</span>
    quicklist<span class="token operator">-&gt;</span>compress <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment">/* -2 意思是一个压缩链表的字节数最大是8k */</span>
    quicklist<span class="token operator">-&gt;</span>fill <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">;</span>
    quicklist<span class="token operator">-&gt;</span>bookmark_count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> quicklist<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过<code>quicklistCreate</code>函数初始化，fill的值默认是-2，表示节点中每个压缩链表最大是8K。</p><h3 id="数据插入" tabindex="-1"><a class="header-anchor" href="#数据插入"><span>数据插入</span></a></h3><p>数据插入分两种情况，一是在链表的首尾插入，二是在链表中的某个节点插入。</p><h4 id="首尾插入" tabindex="-1"><a class="header-anchor" href="#首尾插入"><span>首尾插入</span></a></h4><p>原理：先判断首/尾的节点是否还能继续插入数据，如果可以直接插入（调用压缩链表的函数ziplistPush），否则新建一个<code>quicklistNode</code>，替换首/尾节点。</p><p>在头部插入代码</p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">quicklistPushHead</span><span class="token punctuation">(</span>quicklist <span class="token operator">*</span>quicklist<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>value<span class="token punctuation">,</span> <span class="token class-name">size_t</span> sz<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    quicklistNode <span class="token operator">*</span>orig_head <span class="token operator">=</span> quicklist<span class="token operator">-&gt;</span>head<span class="token punctuation">;</span>
    <span class="token comment">/*
     * 判断头节点还能不能插入节点，可以的话在头节点插入
     * 否则，新建一个节点
     * */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">likely</span><span class="token punctuation">(</span>
            <span class="token function">_quicklistNodeAllowInsert</span><span class="token punctuation">(</span>quicklist<span class="token operator">-&gt;</span>head<span class="token punctuation">,</span> quicklist<span class="token operator">-&gt;</span>fill<span class="token punctuation">,</span> sz<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        quicklist<span class="token operator">-&gt;</span>head<span class="token operator">-&gt;</span>zl <span class="token operator">=</span>
            <span class="token function">ziplistPush</span><span class="token punctuation">(</span>quicklist<span class="token operator">-&gt;</span>head<span class="token operator">-&gt;</span>zl<span class="token punctuation">,</span> value<span class="token punctuation">,</span> sz<span class="token punctuation">,</span> ZIPLIST_HEAD<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">quicklistNodeUpdateSz</span><span class="token punctuation">(</span>quicklist<span class="token operator">-&gt;</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        quicklistNode <span class="token operator">*</span>node <span class="token operator">=</span> <span class="token function">quicklistCreateNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        node<span class="token operator">-&gt;</span>zl <span class="token operator">=</span> <span class="token function">ziplistPush</span><span class="token punctuation">(</span><span class="token function">ziplistNew</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> value<span class="token punctuation">,</span> sz<span class="token punctuation">,</span> ZIPLIST_HEAD<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token function">quicklistNodeUpdateSz</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">_quicklistInsertNodeBefore</span><span class="token punctuation">(</span>quicklist<span class="token punctuation">,</span> quicklist<span class="token operator">-&gt;</span>head<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    quicklist<span class="token operator">-&gt;</span>count<span class="token operator">++</span><span class="token punctuation">;</span>
    quicklist<span class="token operator">-&gt;</span>head<span class="token operator">-&gt;</span>count<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>orig_head <span class="token operator">!=</span> quicklist<span class="token operator">-&gt;</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在尾部插入代码</p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">quicklistPushTail</span><span class="token punctuation">(</span>quicklist <span class="token operator">*</span>quicklist<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>value<span class="token punctuation">,</span> <span class="token class-name">size_t</span> sz<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    quicklistNode <span class="token operator">*</span>orig_tail <span class="token operator">=</span> quicklist<span class="token operator">-&gt;</span>tail<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">likely</span><span class="token punctuation">(</span>
            <span class="token function">_quicklistNodeAllowInsert</span><span class="token punctuation">(</span>quicklist<span class="token operator">-&gt;</span>tail<span class="token punctuation">,</span> quicklist<span class="token operator">-&gt;</span>fill<span class="token punctuation">,</span> sz<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        quicklist<span class="token operator">-&gt;</span>tail<span class="token operator">-&gt;</span>zl <span class="token operator">=</span>
            <span class="token function">ziplistPush</span><span class="token punctuation">(</span>quicklist<span class="token operator">-&gt;</span>tail<span class="token operator">-&gt;</span>zl<span class="token punctuation">,</span> value<span class="token punctuation">,</span> sz<span class="token punctuation">,</span> ZIPLIST_TAIL<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">quicklistNodeUpdateSz</span><span class="token punctuation">(</span>quicklist<span class="token operator">-&gt;</span>tail<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        quicklistNode <span class="token operator">*</span>node <span class="token operator">=</span> <span class="token function">quicklistCreateNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        node<span class="token operator">-&gt;</span>zl <span class="token operator">=</span> <span class="token function">ziplistPush</span><span class="token punctuation">(</span><span class="token function">ziplistNew</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> value<span class="token punctuation">,</span> sz<span class="token punctuation">,</span> ZIPLIST_TAIL<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token function">quicklistNodeUpdateSz</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">_quicklistInsertNodeAfter</span><span class="token punctuation">(</span>quicklist<span class="token punctuation">,</span> quicklist<span class="token operator">-&gt;</span>tail<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    quicklist<span class="token operator">-&gt;</span>count<span class="token operator">++</span><span class="token punctuation">;</span>
    quicklist<span class="token operator">-&gt;</span>tail<span class="token operator">-&gt;</span>count<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>orig_tail <span class="token operator">!=</span> quicklist<span class="token operator">-&gt;</span>tail<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="某个值前后插入" tabindex="-1"><a class="header-anchor" href="#某个值前后插入"><span>某个值前后插入</span></a></h4><p>我们把在某个元素之前或者之后插入的这个元素称为 基准元素</p><p>下面是每个变量的含义</p><p>full：基准元素所在的压缩链表是否允许继续插入元素</p><p>at_tail：基准元素在压缩链表的尾部</p><p>at_head：基准元素在压缩链表的头部</p><p>full_next：基准元素所在的链表的下一个链表是否允许插入</p><p>full_prev：基准元素所在的链表的上一个链表是否允许插入</p><p>after：在基准元素的之前还是之后插入</p><p>原理：分为一下几种情况</p><ol><li>如果没有指定节点，创建一个新的节点，并插入元素，直接返回</li><li>如果压缩链表没有满，并且是在基准元素之后插入的，直接插入</li><li>如果压缩链表没有满，并且是在基准元素之前插入的，直接插入</li><li>基准元素在链表的尾部，要在基准元素之后插入，压缩链表满了，但下一个压缩链表节点没有满，直接在下一个压缩链表插入</li><li>基准元素在链表的头部，要在基准元素之前插入，压缩链表满了，但上一个压缩链表节点没有满，直接在上一个压缩链表插入</li><li>基准元素在链表的尾部，要在基准元素之后插入，压缩链表满了，下一个压缩链表节点也满，创建一个新的压缩链表节点，插在中间</li><li>基准元素在链表的头部，要在基准元素之前插入，压缩链表满了，上一个压缩链表节点也满，创建一个新的压缩链表节点，插在中间</li><li>基准元素所在的链表满了，但基准元素不在链表的头部和尾部，需要把当前链表节点分裂成两个链表节点，如何插入数据，拼接。</li></ol><p>具体的代码如下：</p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/* 在某个元素的之前或者之后插入 */</span>
REDIS_STATIC <span class="token keyword">void</span> <span class="token function">_quicklistInsert</span><span class="token punctuation">(</span>quicklist <span class="token operator">*</span>quicklist<span class="token punctuation">,</span> quicklistEntry <span class="token operator">*</span>entry<span class="token punctuation">,</span>
                                   <span class="token keyword">void</span> <span class="token operator">*</span>value<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token class-name">size_t</span> sz<span class="token punctuation">,</span> <span class="token keyword">int</span> after<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/*
     * 我们把在某个元素之前或者之后插入的这个元素称为 基准元素
     * 下面是每个变量的含义
     * full：基准元素所在的压缩链表是否允许继续插入元素
     * at_tail：基准元素在压缩链表的尾部
     * at_head：基准元素在压缩链表的头部
     * full_next：基准元素所在的链表的下一个链表是否允许插入
     * full_prev：基准元素所在的链表的上一个链表是否允许插入
     * after：在基准元素的之前还是之后插入
     * */</span>
    <span class="token keyword">int</span> full <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> at_tail <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> at_head <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> full_next <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> full_prev <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> fill <span class="token operator">=</span> quicklist<span class="token operator">-&gt;</span>fill<span class="token punctuation">;</span>
    quicklistNode <span class="token operator">*</span>node <span class="token operator">=</span> entry<span class="token operator">-&gt;</span>node<span class="token punctuation">;</span>
    quicklistNode <span class="token operator">*</span>new_node <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>

    <span class="token comment">/* 如果没有指定节点，创建一个新的节点，并插入元素，直接返回 */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">/* we have no reference node, so let&#39;s create only node in the list */</span>
        <span class="token function">D</span><span class="token punctuation">(</span><span class="token string">&quot;No node given!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        new_node <span class="token operator">=</span> <span class="token function">quicklistCreateNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        new_node<span class="token operator">-&gt;</span>zl <span class="token operator">=</span> <span class="token function">ziplistPush</span><span class="token punctuation">(</span><span class="token function">ziplistNew</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> value<span class="token punctuation">,</span> sz<span class="token punctuation">,</span> ZIPLIST_HEAD<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">__quicklistInsertNode</span><span class="token punctuation">(</span>quicklist<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> new_node<span class="token punctuation">,</span> after<span class="token punctuation">)</span><span class="token punctuation">;</span>
        new_node<span class="token operator">-&gt;</span>count<span class="token operator">++</span><span class="token punctuation">;</span>
        quicklist<span class="token operator">-&gt;</span>count<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/* Populate accounting flags for easier boolean checks later */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">_quicklistNodeAllowInsert</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> fill<span class="token punctuation">,</span> sz<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">D</span><span class="token punctuation">(</span><span class="token string">&quot;Current node is full with count %d with requested fill %lu&quot;</span><span class="token punctuation">,</span>
          node<span class="token operator">-&gt;</span>count<span class="token punctuation">,</span> fill<span class="token punctuation">)</span><span class="token punctuation">;</span>
        full <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>after <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>entry<span class="token operator">-&gt;</span>offset <span class="token operator">==</span> node<span class="token operator">-&gt;</span>count<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">D</span><span class="token punctuation">(</span><span class="token string">&quot;At Tail of current ziplist&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        at_tail <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">_quicklistNodeAllowInsert</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>next<span class="token punctuation">,</span> fill<span class="token punctuation">,</span> sz<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">D</span><span class="token punctuation">(</span><span class="token string">&quot;Next node is full too.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            full_next <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>after <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>entry<span class="token operator">-&gt;</span>offset <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">D</span><span class="token punctuation">(</span><span class="token string">&quot;At Head&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        at_head <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">_quicklistNodeAllowInsert</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>prev<span class="token punctuation">,</span> fill<span class="token punctuation">,</span> sz<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">D</span><span class="token punctuation">(</span><span class="token string">&quot;Prev node is full too.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            full_prev <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/* Now determine where and how to insert the new element */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>full <span class="token operator">&amp;&amp;</span> after<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">/* 1、压缩链表未满
         * 2、在基准元素之后插入
         * */</span>
        <span class="token function">D</span><span class="token punctuation">(</span><span class="token string">&quot;Not full, inserting after current position.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">quicklistDecompressNodeForUse</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>next <span class="token operator">=</span> <span class="token function">ziplistNext</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>zl<span class="token punctuation">,</span> entry<span class="token operator">-&gt;</span>zi<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            node<span class="token operator">-&gt;</span>zl <span class="token operator">=</span> <span class="token function">ziplistPush</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>zl<span class="token punctuation">,</span> value<span class="token punctuation">,</span> sz<span class="token punctuation">,</span> ZIPLIST_TAIL<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            node<span class="token operator">-&gt;</span>zl <span class="token operator">=</span> <span class="token function">ziplistInsert</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>zl<span class="token punctuation">,</span> next<span class="token punctuation">,</span> value<span class="token punctuation">,</span> sz<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        node<span class="token operator">-&gt;</span>count<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token function">quicklistNodeUpdateSz</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">quicklistRecompressOnly</span><span class="token punctuation">(</span>quicklist<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>full <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>after<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">/* 1、压缩链表未满
         * 2、在基准元素之前插入
         * */</span>
        <span class="token function">D</span><span class="token punctuation">(</span><span class="token string">&quot;Not full, inserting before current position.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">quicklistDecompressNodeForUse</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
        node<span class="token operator">-&gt;</span>zl <span class="token operator">=</span> <span class="token function">ziplistInsert</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>zl<span class="token punctuation">,</span> entry<span class="token operator">-&gt;</span>zi<span class="token punctuation">,</span> value<span class="token punctuation">,</span> sz<span class="token punctuation">)</span><span class="token punctuation">;</span>
        node<span class="token operator">-&gt;</span>count<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token function">quicklistNodeUpdateSz</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">quicklistRecompressOnly</span><span class="token punctuation">(</span>quicklist<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>full <span class="token operator">&amp;&amp;</span> at_tail <span class="token operator">&amp;&amp;</span> node<span class="token operator">-&gt;</span>next <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>full_next <span class="token operator">&amp;&amp;</span> after<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">/* 1、在基准元素之后插入 */</span>
        <span class="token comment">/* 2、基准元素所在的链表不允许插入，并且基准链表在链表的尾部，但下一个压缩链表还允许插入 */</span>
        <span class="token comment">/* If we are: at tail, next has free space, and inserting after:
         *   - insert entry at head of next node. */</span>
        <span class="token function">D</span><span class="token punctuation">(</span><span class="token string">&quot;Full and tail, but next isn&#39;t full; inserting next node head&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        new_node <span class="token operator">=</span> node<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
        <span class="token function">quicklistDecompressNodeForUse</span><span class="token punctuation">(</span>new_node<span class="token punctuation">)</span><span class="token punctuation">;</span>
        new_node<span class="token operator">-&gt;</span>zl <span class="token operator">=</span> <span class="token function">ziplistPush</span><span class="token punctuation">(</span>new_node<span class="token operator">-&gt;</span>zl<span class="token punctuation">,</span> value<span class="token punctuation">,</span> sz<span class="token punctuation">,</span> ZIPLIST_HEAD<span class="token punctuation">)</span><span class="token punctuation">;</span>
        new_node<span class="token operator">-&gt;</span>count<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token function">quicklistNodeUpdateSz</span><span class="token punctuation">(</span>new_node<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">quicklistRecompressOnly</span><span class="token punctuation">(</span>quicklist<span class="token punctuation">,</span> new_node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>full <span class="token operator">&amp;&amp;</span> at_head <span class="token operator">&amp;&amp;</span> node<span class="token operator">-&gt;</span>prev <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>full_prev <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>after<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">/* 1、在基准元素的之前插入 */</span>
        <span class="token comment">/* 2、基准元素所在的链表不允许插入，并且基准元素在链表的头部，但上一个压缩链表还允许插入 */</span>
        <span class="token comment">/* If we are: at head, previous has free space, and inserting before:
         *   - insert entry at tail of previous node. */</span>
        <span class="token function">D</span><span class="token punctuation">(</span><span class="token string">&quot;Full and head, but prev isn&#39;t full, inserting prev node tail&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        new_node <span class="token operator">=</span> node<span class="token operator">-&gt;</span>prev<span class="token punctuation">;</span>
        <span class="token function">quicklistDecompressNodeForUse</span><span class="token punctuation">(</span>new_node<span class="token punctuation">)</span><span class="token punctuation">;</span>
        new_node<span class="token operator">-&gt;</span>zl <span class="token operator">=</span> <span class="token function">ziplistPush</span><span class="token punctuation">(</span>new_node<span class="token operator">-&gt;</span>zl<span class="token punctuation">,</span> value<span class="token punctuation">,</span> sz<span class="token punctuation">,</span> ZIPLIST_TAIL<span class="token punctuation">)</span><span class="token punctuation">;</span>
        new_node<span class="token operator">-&gt;</span>count<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token function">quicklistNodeUpdateSz</span><span class="token punctuation">(</span>new_node<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">quicklistRecompressOnly</span><span class="token punctuation">(</span>quicklist<span class="token punctuation">,</span> new_node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>full <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>at_tail <span class="token operator">&amp;&amp;</span> node<span class="token operator">-&gt;</span>next <span class="token operator">&amp;&amp;</span> full_next <span class="token operator">&amp;&amp;</span> after<span class="token punctuation">)</span> <span class="token operator">||</span>
                        <span class="token punctuation">(</span>at_head <span class="token operator">&amp;&amp;</span> node<span class="token operator">-&gt;</span>prev <span class="token operator">&amp;&amp;</span> full_prev <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>after<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">/*
         * 1、基准元素所在的链表已满
         * 2、在基准元素之后插入，基准元素在链表的尾部，但基准元素的下一个链表已满
         * 3、在基准元素之前插入，基准元素在链表的头部，但基准元素的上一个链表已满
         * */</span>
        <span class="token comment">/* If we are: full, and our prev/next is full, then:
         *   - create new node and attach to quicklist */</span>
        <span class="token function">D</span><span class="token punctuation">(</span><span class="token string">&quot;\\tprovisioning new node...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        new_node <span class="token operator">=</span> <span class="token function">quicklistCreateNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        new_node<span class="token operator">-&gt;</span>zl <span class="token operator">=</span> <span class="token function">ziplistPush</span><span class="token punctuation">(</span><span class="token function">ziplistNew</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> value<span class="token punctuation">,</span> sz<span class="token punctuation">,</span> ZIPLIST_HEAD<span class="token punctuation">)</span><span class="token punctuation">;</span>
        new_node<span class="token operator">-&gt;</span>count<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token function">quicklistNodeUpdateSz</span><span class="token punctuation">(</span>new_node<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">__quicklistInsertNode</span><span class="token punctuation">(</span>quicklist<span class="token punctuation">,</span> node<span class="token punctuation">,</span> new_node<span class="token punctuation">,</span> after<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>full<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">/* 1、基准元素所在的链表已满 */</span>
        <span class="token comment">/* else, node is full we need to split it. */</span>
        <span class="token comment">/* covers both after and !after cases */</span>
        <span class="token function">D</span><span class="token punctuation">(</span><span class="token string">&quot;\\tsplitting node...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">quicklistDecompressNodeForUse</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
        new_node <span class="token operator">=</span> <span class="token function">_quicklistSplitNode</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> entry<span class="token operator">-&gt;</span>offset<span class="token punctuation">,</span> after<span class="token punctuation">)</span><span class="token punctuation">;</span>
        new_node<span class="token operator">-&gt;</span>zl <span class="token operator">=</span> <span class="token function">ziplistPush</span><span class="token punctuation">(</span>new_node<span class="token operator">-&gt;</span>zl<span class="token punctuation">,</span> value<span class="token punctuation">,</span> sz<span class="token punctuation">,</span>
                                   after <span class="token operator">?</span> ZIPLIST_HEAD <span class="token operator">:</span> ZIPLIST_TAIL<span class="token punctuation">)</span><span class="token punctuation">;</span>
        new_node<span class="token operator">-&gt;</span>count<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token function">quicklistNodeUpdateSz</span><span class="token punctuation">(</span>new_node<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">__quicklistInsertNode</span><span class="token punctuation">(</span>quicklist<span class="token punctuation">,</span> node<span class="token punctuation">,</span> new_node<span class="token punctuation">,</span> after<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">_quicklistMergeNodes</span><span class="token punctuation">(</span>quicklist<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    quicklist<span class="token operator">-&gt;</span>count<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="其他" tabindex="-1"><a class="header-anchor" href="#其他"><span>其他</span></a></h3><p>数据的删除、替换、遍历啥的其实和压缩链表都是差不多的，就不具体描述了。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>计算机领域有一句名言</p><p>“Any problem in computer science can be solved by anther layer of indirection.”</p><p>“计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决”</p>`,49),o=[e];function c(i,l){return s(),a("div",null,o)}const k=n(p,[["render",c],["__file","数据结构04-快速链表.html.vue"]]),d=JSON.parse('{"path":"/tech/redis/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8404-%E5%BF%AB%E9%80%9F%E9%93%BE%E8%A1%A8.html","title":"数据结构04-快速链表","lang":"zh-CN","frontmatter":{"date":"2021-12-06T22:13:00.000Z","category":["Redis"],"tag":["Redis","算法"],"description":"数据结构04-快速链表 img （开局一张图，下面全靠编） 在Redis 3.2之前的版本，Redis使用压缩链表（ziplist）和双端链表（adlist）来实现List。当元素个数比较少的情况下，使用压缩链表，当数据到一定的量，升级为双端链表。这是因为压缩链表可以节省内存空间，但压缩链表的数据是连续的，数据的插入压缩链表需要重新分配内存，这会影响到...","head":[["meta",{"property":"og:url","content":"https://dhbin.cn/tech/redis/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8404-%E5%BF%AB%E9%80%9F%E9%93%BE%E8%A1%A8.html"}],["meta",{"property":"og:site_name","content":"HB技术栈"}],["meta",{"property":"og:title","content":"数据结构04-快速链表"}],["meta",{"property":"og:description","content":"数据结构04-快速链表 img （开局一张图，下面全靠编） 在Redis 3.2之前的版本，Redis使用压缩链表（ziplist）和双端链表（adlist）来实现List。当元素个数比较少的情况下，使用压缩链表，当数据到一定的量，升级为双端链表。这是因为压缩链表可以节省内存空间，但压缩链表的数据是连续的，数据的插入压缩链表需要重新分配内存，这会影响到..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://cdn.dhbin.cn/202303232003998.jpeg"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-03-23T12:17:45.000Z"}],["meta",{"property":"article:author","content":"DHB"}],["meta",{"property":"article:tag","content":"Redis"}],["meta",{"property":"article:tag","content":"算法"}],["meta",{"property":"article:published_time","content":"2021-12-06T22:13:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-03-23T12:17:45.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"数据结构04-快速链表\\",\\"image\\":[\\"https://cdn.dhbin.cn/202303232003998.jpeg\\"],\\"datePublished\\":\\"2021-12-06T22:13:00.000Z\\",\\"dateModified\\":\\"2023-03-23T12:17:45.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"DHB\\",\\"url\\":\\"https://dhbin.cn\\"}]}"]]},"headers":[{"level":2,"title":"原理","slug":"原理","link":"#原理","children":[]},{"level":2,"title":"数据结构","slug":"数据结构","link":"#数据结构","children":[{"level":3,"title":"quicklist","slug":"quicklist","link":"#quicklist","children":[]},{"level":3,"title":"quicklistNode","slug":"quicklistnode","link":"#quicklistnode","children":[]}]},{"level":2,"title":"逻辑","slug":"逻辑","link":"#逻辑","children":[{"level":3,"title":"如何判断quicklistNode能否继续插入数据","slug":"如何判断quicklistnode能否继续插入数据","link":"#如何判断quicklistnode能否继续插入数据","children":[]},{"level":3,"title":"初始化","slug":"初始化","link":"#初始化","children":[]},{"level":3,"title":"数据插入","slug":"数据插入","link":"#数据插入","children":[]},{"level":3,"title":"其他","slug":"其他","link":"#其他","children":[]}]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]}],"git":{"createdTime":1679573865000,"updatedTime":1679573865000,"contributors":[{"name":"dhb","email":"xx158@qq.com","commits":1}]},"readingTime":{"minutes":9.32,"words":2796},"localizedDate":"2021年12月6日","excerpt":"\\n<p><img src=\\"https://cdn.dhbin.cn/202303232003998.jpeg\\" alt=\\"img\\"></p>\\n<p>（开局一张图，下面全靠编）</p>\\n<p>在Redis 3.2之前的版本，Redis使用压缩链表（ziplist）和双端链表（adlist）来实现List。当元素个数比较少的情况下，使用压缩链表，当数据到一定的量，升级为双端链表。这是因为压缩链表可以节省内存空间，但压缩链表的数据是连续的，数据的插入压缩链表需要重新分配内存，这会影响到压缩链表的执行效率，所以升级到双端链表。快速链表是综合考虑时间效率和空间效率引入的新型数据结构。</p>\\n<h2>原理</h2>","autoDesc":true}');export{k as comp,d as data};
